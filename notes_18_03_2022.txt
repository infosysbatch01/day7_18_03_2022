public class Numbers{
  
  private void add(int a,int b){}
  private int add(int a,int b){}
}
// We have different return type in the above example
// We don't consider return type to decide whether two or methods
// are overloaded methods or not
public class Numbers{
  
  private void add(int a,int b){}
  private int add(float a,float b){}
}// The above example is of method overloading.
public class Numbers{
  
  private void add(int a,int b){}
  private int add(int a,int b,int c){}
}// The above example is of method overloading. 

public class Numbers{
  
  private void add(int a,float b){}
  private int add(float a,int b){}
}// The above example is of method overloading.
--------------------------------------------------------------------------------------------------
String substring(int startIndex)
String substring(int startIndex, int endIndex)
------------------------------------------------------------------------------------------------------
Whenever we are discussing dynamic polymorphism or method overriding we need to have Inheritance with the code.

 class Person{
    public void disp(){
    System.out.println("I am the disp method of the base class");
   }
 }

 class Employee extends Person {
  public void disp(){
    System.out.println("I am the disp method of the derived class");
   }
 }
For method overriding:
* methods will be having the same name in the Parent class and the Child class.
* Return type will be same or of covariant type.
* Number of parameters will be same.
* The parameter's datatype will be same.

public class Base1 {
   public int calculate(int a,int b){   // overridden method
    System.out.println("I am in the base class");
    return a+b;
   }
 }

public class Derived1 extends Base1 {
  public int calculate(int x, int y){     // overriding method
    System.out.println("I am the derived class");
    return x*y;
  }
}


public class Main1{
   public static void main(String args[]){
     Derived1 derived=new Derived1();
     int res=derived.calculate(4,5);
     // Derived class calculate method will override
     // the base class calculate
     System.out.println(res);
    }
  }
----------------------------------------------------------------------------------------------------
public class Base2 {
   private int calculate(int a,int b){   // private method/methods are not overridden
    System.out.println("I am in the base class");
    return a+b;
   }
 }

public class Derived2 extends Base2 {
  public int calculate(int x, int y){     
    System.out.println("I am the derived class");
    return x*y;
  }
}


public class Main2{
   public static void main(String args[]){
     Derived2 derived=new Derived2();
     int res=derived.calculate(4,5);
     System.out.println(res);
    }
  }
------------------------------------------------------------------------------
The access modifiers from most restricted to least restricted
private======>default=======>protected=======>public
When we go for method overriding the overridden method should have access specifier same as
that of the overridden method or with more scope than the overridden method. The
below code will show compilation error because the overridden method is having public scope
where as overriding os having the restricted scope of default.
public class Base3 {
   public int calculate(int a,int b){   // private method/methods are not overridden
    System.out.println("I am in the base class");
    return a+b;
   }
 }

public class Derived3 extends Base3 {
   int calculate(int x, int y){     
    System.out.println("I am the derived class");
    return x*y;
  }
}
--------------------------------------------------------------------
The below code is fine as the overriding method is having higher scope of accessibility as 
comparison to the overridden method.


public class Base4 {
    int calculate(int a,int b){   // private method/methods are not overridden
    System.out.println("I am in the base class");
    return a+b;
   }
 }

public class Derived4 extends Base4 {
   public int calculate(int x, int y){     
    System.out.println("I am the derived class");
    return x*y;
  }
}


public class Main4{
   public static void main(String args[]){
     Derived4 derived=new Derived4();
     int res=derived.calculate(4,5);
     System.out.println(res);
    }
  }
----------------------------------------------------------------------------

public class Base5 {
    int calculate(int a,int b){   // private method/methods are not overridden
    System.out.println("I am in the base class");
    return a+b;
   }
 }

public class Derived5 extends Base5 {
   public int calculate(int x, int y){     
    System.out.println("I am the derived class");
    return x*y;
  }
}


public class Main5{
   public static void main(String args[]){
     Base5 base=new Base5();
     int res=base.calculate(4,5);   // The base class calculate method is called
     Derived5 derived=new Derived5();
     res=derived.calculate(4,5);    // The derived class calculate method is called
     System.out.println(res);
     Base5 base2=new Derived5(); // Reference is of the base type and object is of the derived type
     res=base2.calculate(10,10);   //In this line the Derived class calculate method is called
     System.out.println(res);   
    }
  }
-------------------------------------------------------------
Q How the type conversion and casting takes place in Java for reference type?
A The classes which are having parent child relationship , with those classes we can implement type
conversion and type casting.Type casting cannot happen between the classes which are not related with
parent child relationship.

   public class Computer{

   }

   public class Laptop extends Computer {

   }

   public class ComputerMain{
     public static void main(String args[]){
       Computer computer=null;
       computer=new Laptop();  // The Computer and Laptop are having parent child relationship
     }
  }

-----------------------------------------------------------------------------------

public class Computer{

   }

   public class Laptop extends Computer {

   }

   public class ComputerMain{
     public static void main(String args[]){
       Computer computer=null; // we are initialising the reference variable with null which means currently the reference variable is not storing the address of any object.
       computer=new Laptop();  // The Computer and Laptop are having parent child relationship
     }
  }
----------------------------------------------------------------------------------------------------
public class Computer1{
    public void processing(){
     System.out.println("Computer will do processing");
    }
   }

   public class Laptop1 extends Computer1 {
   public void processing(){
     System.out.println("I am the Laptop processor");
    }
   }

   public class ComputerMain1{
     public static void main(String args[]){
       Computer1 computer=null; // we are initialising the reference variable with null which means currently the reference variable is not storing the address of any object.
       computer=new Laptop1();  // The Computer and Laptop are having parent child relationship
       computer.processing(); // It shows I am Laptop processor
       // The above execution is because of dynamic polymorphism because object is created during the
      // runtime and when we call processing method after the object creation, first it checks whether
      // we have processing method in the base class, if the method declaration is present in the
      // base class, then it checks the derived class as the object is of Derived type. Now if it
     // is getting the method in the derived class, that derived class method is invoked.
     }
  }

Q What will happen if we have a method in the base class but we dont have a similar method in the 
  Derived class.
A In that case the base class method will be called.

public class Computer2{
    public void processing(){
     System.out.println("Computer will do processing");
    }
   }

   public class Laptop2 extends Computer2 {
  
   }

   public class ComputerMain2{
     public static void main(String args[]){
       Computer2 computer=null; // we are initialising the reference variable with null which means currently the reference variable is not storing the address of any object.
       computer=new Laptop2();  // The Computer and Laptop are having parent child relationship
       computer.processing(); // Computer will do processing
       // The above execution is because of dynamic polymorphism because object is created during the
      // runtime and when we call processing method after the object creation, first it checks whether
      // we have processing method in the base class, if the method declaration is present in the
      // base class, then it checks the derived class as the object is of Derived type. Now if it
     // is getting the method in the derived class, that derived class method is invoked.
     }
  }
---------------------------------------------------------------------------------------------------
Q If we have a method which is only in the subclass but we dont have a method in the base class.
Can we call that method with the reference of base class and object of derived class?
A No

public class Computer3{
   
   }

   public class Laptop3 extends Computer3 {
     public void processing(){
     System.out.println("I am the processor of laptop");
    }
   }

   public class ComputerMain3{
     public static void main(String args[]){
       Computer3 computer=null; // we are initialising the reference variable with null which means currently the reference variable is not storing the address of any object.
       computer=new Laptop3();  // The Computer and Laptop are having parent child relationship
       computer.processing();   // In this line we will have compilation error as the method is 
      // not declared in the Parent class
     }
  }
-----------------------------------------------------------------------------
Q Do we have any solution for the above challenge?
A Yes . With type casting.

public class Computer4{
   
   }

   public class Laptop4 extends Computer4 {
     public void processing(){
     System.out.println("I am the processor of laptop");
    }
   }

   public class ComputerMain4{
     public static void main(String args[]){
       Computer4 computer=null; // we are initialising the reference variable with null which means currently the reference variable is not storing the address of any object.
       computer=new Laptop4();  // The Computer and Laptop are having parent child relationship
       Laptop4 laptop=(Laptop)computer; // Casting
       //((Laptop)computer).processing(); 
      laptop.processing();   
     }
  }

[In reference type casting is always preceeded by type conversion]
It is similar to pouring the content of smaller jug into the bigger jug and again pouring the 
content from bigger jug back to the smaller jug.
-------------------------------------------------------------------------------------
// For the following code we wont be getting any compilation error but we will get Runtime error
Exception in thread "main" java.lang.ClassCastException: class Computer5 cannot be cast to class Laptop5 (Computer5 and Laptop5 are in unnamed module of loader 'app')
	at ComputerMain5.main(ComputerMain5.java:4)

To decide type conversion we have to check is relation. Example
Laptop is a Computer        Computer=Laptop ( conversion) 
Is a relationship from down to up.
public class Computer5{
   
   }

   public class Laptop5 extends Computer5 {
     public void processing(){
     System.out.println("I am the processor of laptop");
    }
   }

   public class ComputerMain5{
     public static void main(String args[]){
       Computer5 computer=new Computer5();
       Laptop5 laptop=(Laptop5)computer; 
       laptop.processing();   
     }
  }
---------------------------------------------
Computer computer=new Computer();
Computer computer2=computer;
---------------------------------------------------------------------------------------

public class Base6 {
   public void disp(){
    System.out.println("I am the base class display method");
   }
}

public class Derived6 extends Base6{
  public void disp() {
    super.disp(); // super is a keyword which is used to represent the immediate parent class
    System.out.println("I am the derived class display method");
   }
}

public class Main6{
   public static void main(String args[]) {
      Derived6 derived=new Derived6();
      derived.disp();
   }
 }
-----------------------------------

  public class BaseA {
    public void disp(){
   
    }
  }
 
 public class BaseB extends BaseA {
   public void disp(){
   super.disp();
  }
}

  public class Derived extends BaseB {
   public void disp() {
   super.super.disp();  // This way is not correct
   super.disp();
  }
 }
-----------------------------------------------------------------------------------------
All the classes in Java ( Pre defined or user defined ) are subclasses of Object class.
So when we create our own class , that is also inherited class. In the following example
though we are not writing Employee extends Object, then also Employee is a subclass of Object.
  
  public class Employee {}
---------------------------------------------------------------------------------------------
  public class Person {}
  public class Employee extends Person{}
  
   Object
     |
     |
     |
   Person
     |
     |
     |
  Employee
As we dont have the concept of multiple inheritance but we have multi level inheritance. The
above example is of multi level inheritance. So in the example above Person is extending Object
and Employee is extending Person. So Employee is inheriting Object via Person class.
   A    B
     C
public class A{}
public class B{}
public class C extends A,B {}  // we cannot have multiple inheritance in Java through classes.
---------------------------------------------------------------------------------------------
We have 8 Wrapper classes. String is not a wrapper class.
Primitive          Wrapper Classes
char               Character
byte               Byte
short              Short
int                Integer
float              Float
double             Double
boolean            Boolean
---------------------------------------------------------------------------------------------------

  public class Employee1{

    private int id;
    private String name;
    private String desig;
    private float basic;

    public Employee1(int id, String name, String desig, float basic){
     this.id=id;
     this.name=name;
     this.desig=desig;
     this.basic=basic;
    }
 }

 public class EmployeeMain1{
    public static void main(String args[]) {
       Employee1 emp1=new Employee1(1,"Ratish","Manager",34000);
       Employee1 emp2=new Employee1(1,"Ratish","Manager",34000);
       Employee1 emp3=new Employee1(2,"Javed","Manager",35000);
       String str1="Hello";
       String str2="Hello";
       System.out.println(str1.equals(str2)); // true
       System.out.println(str1==str2); // true because str1 and str2 are pointing to the same String literal
       String str3=new String("Hello");
       String str4=new String("Hello");
       System.out.println(str3.equals(str4)); // true
       System.out.println(str3==str4);    // false
       System.out.println(emp1.equals(emp2)); // false because the equals method is inherited from 
       // the Object class and equals method of the object class compares the reference and not the
       // equality of the contenf
       System.out.println(emp1==emp2); // false
       System.out.println(emp1.hashCode()); // hashCode is a method which returns a number returned by 
       // the JVM for unique identification of the object it is related to the address of the object        //created
       System.out.println(emp2.hashCode());
      // As the objects are different so hash value of the objects are also different but according
      // to the specification if two objects are having the same content hashCode value should be 
      // same.
       System.out.println(emp1.toString());  //className@hexadecimal representation of the hashCode value
       System.out.println(emp2.toString());
       System.out.println(emp1);
       System.out.println(emp2);
     }
  }
 ---------------------------------------------------------------------------------------------
public class Employee2{

    private int id;
    private String name;
    private String desig;
    private float basic;

    public Employee2(int id, String name, String desig, float basic){
     this.id=id;
     this.name=name;
     this.desig=desig;
     this.basic=basic;
     
    }

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + Float.floatToIntBits(basic);
		result = prime * result + ((desig == null) ? 0 : desig.hashCode());
		result = prime * result + id;
		result = prime * result + ((name == null) ? 0 : name.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Employee2 other = (Employee2) obj;
		if (Float.floatToIntBits(basic) != Float.floatToIntBits(other.basic))
			return false;
		if (desig == null) {
			if (other.desig != null)
				return false;
		} else if (!desig.equals(other.desig))
			return false;
		if (id != other.id)
			return false;
		if (name == null) {
			if (other.name != null)
				return false;
		} else if (!name.equals(other.name))
			return false;
		return true;
	}

	@Override
	public String toString() {
		//return "Employee2 [id=" + id + ", name=" + name + ", desig=" + desig + ", basic=" + basic + "]";
	     return "ID : "+id+"NAME :"+name+"DESIG :"+desig+"BASIC :"+basic;
	}
	
	
 }

 public class EmployeeMain2{
    public static void main(String args[]) {
       Employee2 emp1=new Employee2(1,"Ratish","Manager",34000);
       Employee2 emp2=new Employee2(1,"Ratish","Manager",34000);
       Employee2 emp3=new Employee2(2,"Javed","Manager",35000);
       String str1="Hello";
       String str2="Hello";
       System.out.println(str1.equals(str2)); // true
       System.out.println(str1==str2); // true because str1 and str2 are pointing to the same String literal
       String str3=new String("Hello");
       String str4=new String("Hello");
       System.out.println(str3.equals(str4)); // true
       System.out.println(str3==str4);    // false
       System.out.println(emp1.equals(emp2)); // true because the equals method we have
       // overridden in the Employee class and these overridden method is checking for the content
       // as the content of emp1 and emp2 are same, it is returning true
       System.out.println(emp1==emp2); // false
       System.out.println(emp1.hashCode()); // hashCode is a method which returns a number returned by 
       // the JVM for unique identification of the object it is related to the address of the object        //created
       System.out.println(emp2.hashCode());
      // As the objects are different so hash value of the objects are also different but according
      // to the specification if two objects are having the same content hashCode value should be 
      // same.After overriding the hashCode method we are getting the same hashCode value 
       // for the objects which are having the same data
       System.out.println(emp1.toString());  //className@hexadecimal representation of the hashCode value
       System.out.println(emp2.toString());
       System.out.println(emp1); // If we are not overriding the toString method, this shows the classname@haxadecimal value for hashCode
       System.out.println(emp2);
       System.out.println(emp3);
     }
  }
 
 -------------------------------------------------------------------------------------------
POINTS TO REMEMBER related to hashcode:
* The hashcode of two object are different as it includes memory address to generate the hashcode
  value.
* It is said that if two objects are having same content, hashcode values will be same for both the
  objects. In java to implement this , we have override the hashCode method in our class.
* If the hashcode is same , it is not guaranteed that the objects will be same.
-------------------------------------------------------------------------------------------------- 