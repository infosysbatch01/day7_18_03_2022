public class Numbers{
  
  private void add(int a,int b){}
  private int add(int a,int b){}
}
// We have different return type in the above example
// We don't consider return type to decide whether two or methods
// are overloaded methods or not
public class Numbers{
  
  private void add(int a,int b){}
  private int add(float a,float b){}
}// The above example is of method overloading.
public class Numbers{
  
  private void add(int a,int b){}
  private int add(int a,int b,int c){}
}// The above example is of method overloading. 

public class Numbers{
  
  private void add(int a,float b){}
  private int add(float a,int b){}
}// The above example is of method overloading.
--------------------------------------------------------------------------------------------------
String substring(int startIndex)
String substring(int startIndex, int endIndex)
------------------------------------------------------------------------------------------------------
Whenever we are discussing dynamic polymorphism or method overriding we need to have Inheritance with the code.

 class Person{
    public void disp(){
    System.out.println("I am the disp method of the base class");
   }
 }

 class Employee extends Person {
  public void disp(){
    System.out.println("I am the disp method of the derived class");
   }
 }
For method overriding:
* methods will be having the same name in the Parent class and the Child class.
* Return type will be same or of covariant type.
* Number of parameters will be same.
* The parameter's datatype will be same.

public class Base1 {
   public int calculate(int a,int b){   // overridden method
    System.out.println("I am in the base class");
    return a+b;
   }
 }

public class Derived1 extends Base1 {
  public int calculate(int x, int y){     // overriding method
    System.out.println("I am the derived class");
    return x*y;
  }
}


public class Main1{
   public static void main(String args[]){
     Derived1 derived=new Derived1();
     int res=derived.calculate(4,5);
     // Derived class calculate method will override
     // the base class calculate
     System.out.println(res);
    }
  }
----------------------------------------------------------------------------------------------------
public class Base2 {
   private int calculate(int a,int b){   // private method/methods are not overridden
    System.out.println("I am in the base class");
    return a+b;
   }
 }

public class Derived2 extends Base2 {
  public int calculate(int x, int y){     
    System.out.println("I am the derived class");
    return x*y;
  }
}


public class Main2{
   public static void main(String args[]){
     Derived2 derived=new Derived2();
     int res=derived.calculate(4,5);
     System.out.println(res);
    }
  }
------------------------------------------------------------------------------
The access modifiers from most restricted to least restricted
private======>default=======>protected=======>public
When we go for method overriding the overridden method should have access specifier same as
that of the overridden method or with more scope than the overridden method. The
below code will show compilation error because the overridden method is having public scope
where as overriding os having the restricted scope of default.
public class Base3 {
   public int calculate(int a,int b){   // private method/methods are not overridden
    System.out.println("I am in the base class");
    return a+b;
   }
 }

public class Derived3 extends Base3 {
   int calculate(int x, int y){     
    System.out.println("I am the derived class");
    return x*y;
  }
}
--------------------------------------------------------------------
The below code is fine as the overriding method is having higher scope of accessibility as 
comparison to the overridden method.


public class Base4 {
    int calculate(int a,int b){   // private method/methods are not overridden
    System.out.println("I am in the base class");
    return a+b;
   }
 }

public class Derived4 extends Base4 {
   public int calculate(int x, int y){     
    System.out.println("I am the derived class");
    return x*y;
  }
}


public class Main4{
   public static void main(String args[]){
     Derived4 derived=new Derived4();
     int res=derived.calculate(4,5);
     System.out.println(res);
    }
  }
----------------------------------------------------------------------------

public class Base5 {
    int calculate(int a,int b){   // private method/methods are not overridden
    System.out.println("I am in the base class");
    return a+b;
   }
 }

public class Derived5 extends Base5 {
   public int calculate(int x, int y){     
    System.out.println("I am the derived class");
    return x*y;
  }
}


public class Main5{
   public static void main(String args[]){
     Base5 base=new Base5();
     int res=base.calculate(4,5);   // The base class calculate method is called
     Derived5 derived=new Derived5();
     res=derived.calculate(4,5);    // The derived class calculate method is called
     System.out.println(res);
     Base5 base2=new Derived5(); // Reference is of the base type and object is of the derived type
     res=base2.calculate(10,10);   //In this line the Derived class calculate method is called
     System.out.println(res);   
    }
  }
-------------------------------------------------------------
Q How the type conversion and casting takes place in Java for reference type?
A The classes which are having parent child relationship , with those classes we can implement type
conversion and type casting.Type casting cannot happen between the classes which are not related with
parent child relationship.

   public class Computer{

   }

   public class Laptop extends Computer {

   }

   public class ComputerMain{
     public static void main(String args[]){
       Computer computer=null;
       computer=new Laptop();  // The Computer and Laptop are having parent child relationship
     }
  }

-----------------------------------------------------------------------------------

public class Computer{

   }

   public class Laptop extends Computer {

   }

   public class ComputerMain{
     public static void main(String args[]){
       Computer computer=null; // we are initialising the reference variable with null which means currently the reference variable is not storing the address of any object.
       computer=new Laptop();  // The Computer and Laptop are having parent child relationship
     }
  }
----------------------------------------------------------------------------------------------------
public class Computer1{
    public void processing(){
     System.out.println("Computer will do processing");
    }
   }

   public class Laptop1 extends Computer1 {
   public void processing(){
     System.out.println("I am the Laptop processor");
    }
   }

   public class ComputerMain1{
     public static void main(String args[]){
       Computer1 computer=null; // we are initialising the reference variable with null which means currently the reference variable is not storing the address of any object.
       computer=new Laptop1();  // The Computer and Laptop are having parent child relationship
       computer.processing(); // It shows I am Laptop processor
       // The above execution is because of dynamic polymorphism because object is created during the
      // runtime and when we call processing method after the object creation, first it checks whether
      // we have processing method in the base class, if the method declaration is present in the
      // base class, then it checks the derived class as the object is of Derived type. Now if it
     // is getting the method in the derived class, that derived class method is invoked.
     }
  }

Q What will happen if we have a method in the base class but we dont have a similar method in the 
  Derived class.
A In that case the base class method will be called.

public class Computer2{
    public void processing(){
     System.out.println("Computer will do processing");
    }
   }

   public class Laptop2 extends Computer2 {
  
   }

   public class ComputerMain2{
     public static void main(String args[]){
       Computer2 computer=null; // we are initialising the reference variable with null which means currently the reference variable is not storing the address of any object.
       computer=new Laptop2();  // The Computer and Laptop are having parent child relationship
       computer.processing(); // Computer will do processing
       // The above execution is because of dynamic polymorphism because object is created during the
      // runtime and when we call processing method after the object creation, first it checks whether
      // we have processing method in the base class, if the method declaration is present in the
      // base class, then it checks the derived class as the object is of Derived type. Now if it
     // is getting the method in the derived class, that derived class method is invoked.
     }
  }
---------------------------------------------------------------------------------------------------
Q If we have a method which is only in the subclass but we dont have a method in the base class.
Can we call that method with the reference of base class and object of derived class?
A No

public class Computer3{
   
   }

   public class Laptop3 extends Computer3 {
     public void processing(){
     System.out.println("I am the processor of laptop");
    }
   }

   public class ComputerMain3{
     public static void main(String args[]){
       Computer3 computer=null; // we are initialising the reference variable with null which means currently the reference variable is not storing the address of any object.
       computer=new Laptop3();  // The Computer and Laptop are having parent child relationship
       computer.processing();   // In this line we will have compilation error as the method is 
      // not declared in the Parent class
     }
  }
-----------------------------------------------------------------------------
Q Do we have any solution for the above challenge?
A Yes . With type casting.

public class Computer4{
   
   }

   public class Laptop4 extends Computer4 {
     public void processing(){
     System.out.println("I am the processor of laptop");
    }
   }

   public class ComputerMain4{
     public static void main(String args[]){
       Computer4 computer=null; // we are initialising the reference variable with null which means currently the reference variable is not storing the address of any object.
       computer=new Laptop4();  // The Computer and Laptop are having parent child relationship
       Laptop4 laptop=(Laptop)computer; // Casting
       //((Laptop)computer).processing(); 
      laptop.processing();   
     }
  }

[In reference type casting is always preceeded by type conversion]
It is similar to pouring the content of smaller jug into the bigger jug and again pouring the 
content from bigger jug back to the smaller jug.
-------------------------------------------------------------------------------------
// For the following code we wont be getting any compilation error but we will get Runtime error
Exception in thread "main" java.lang.ClassCastException: class Computer5 cannot be cast to class Laptop5 (Computer5 and Laptop5 are in unnamed module of loader 'app')
	at ComputerMain5.main(ComputerMain5.java:4)

To decide type conversion we have to check is relation. Example
Laptop is a Computer        Computer=Laptop ( conversion) 
Is a relationship from down to up.
public class Computer5{
   
   }

   public class Laptop5 extends Computer5 {
     public void processing(){
     System.out.println("I am the processor of laptop");
    }
   }

   public class ComputerMain5{
     public static void main(String args[]){
       Computer5 computer=new Computer5();
       Laptop5 laptop=(Laptop5)computer; 
       laptop.processing();   
     }
  }
---------------------------------------------
Computer computer=new Computer();
Computer computer2=computer;
---------------------------------------------------------------------------------------

public class Base6 {
   public void disp(){
    System.out.println("I am the base class display method");
   }
}

public class Derived6 extends Base6{
  public void disp() {
    super.disp(); // super is a keyword which is used to represent the immediate parent class
    System.out.println("I am the derived class display method");
   }
}

public class Main6{
   public static void main(String args[]) {
      Derived6 derived=new Derived6();
      derived.disp();
   }
 }
-----------------------------------

  public class BaseA {
    public void disp(){
   
    }
  }
 
 public class BaseB extends BaseA {
   public void disp(){
   super.disp();
  }
}

  public class Derived extends BaseB {
   public void disp() {
   super.super.disp();  // This way is not correct
   super.disp();
  }
 }
-----------------------------------------------------------------------------------------
  